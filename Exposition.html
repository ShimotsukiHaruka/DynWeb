<!DOCTYPE html>

<html lang="zh-CN">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>虚拟卢浮宫 - 沉浸式展厅</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>

   

    <style>

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {

            overflow: hidden;

            background: #000;

            font-family: 'Times New Roman', serif;

        }

       

        #ui-layer {

            position: absolute;

            top: 0; left: 0; width: 100%; height: 100%;

            display: flex;

            flex-direction: column;

            justify-content: center;

            align-items: center;

            background: rgba(0,0,0,0.85);

            color: #d4af37; /* 金色 */

            z-index: 999;

            transition: opacity 0.5s;

        }

       

        h1 {

            font-size: 3rem;

            letter-spacing: 5px;

            margin-bottom: 20px;

            text-transform: uppercase;

            border-bottom: 2px solid #d4af37;

            padding-bottom: 10px;

        }

       

        p {

            color: #ccc;

            margin-bottom: 30px;

            font-size: 1.2rem;

        }



        #start-btn {

            padding: 15px 40px;

            background: transparent;

            border: 2px solid #d4af37;

            color: #d4af37;

            font-size: 1.2rem;

            cursor: pointer;

            transition: all 0.3s;

            font-family: serif;

        }



        #start-btn:hover {

            background: #d4af37;

            color: #000;

        }



        #instructions {

            position: absolute;

            bottom: 20px;

            left: 20px;

            color: rgba(255,255,255,0.5);

            pointer-events: none;

        }



        /* 十字准星 */

        #crosshair {

            position: absolute;

            top: 50%; left: 50%;

            width: 4px; height: 4px;

            background: rgba(255, 255, 255, 0.5);

            border-radius: 50%;

            transform: translate(-50%, -50%);

            pointer-events: none;

            mix-blend-mode: difference;

        }

    </style>

</head>

<body>



    <div id="ui-layer">

        <h1>Grand Galerie</h1>

        <p>虚拟艺术展厅体验</p>

        <button id="start-btn">进入展厅</button>

    </div>



    <div id="instructions">WASD 移动 | 鼠标 观看 | ESC 退出</div>

    <div id="crosshair"></div>

    <div id="container"></div>



    <script>

        // ==========================================

        // 1. 程序化纹理生成器 (无需外部图片即可产生真实感)

        // ==========================================

        const TextureGen = {

            // 生成拼花木地板纹理

            createParquet: function() {

                const canvas = document.createElement('canvas');

                canvas.width = 1024; canvas.height = 1024;

                const ctx = canvas.getContext('2d');

               

                // 背景色

                ctx.fillStyle = '#5d4037';

                ctx.fillRect(0, 0, 1024, 1024);

               

                // 绘制木纹拼花

                ctx.strokeStyle = '#3e2723';

                ctx.lineWidth = 2;

                const tileSize = 128;

               

                for(let y=0; y<1024; y+=tileSize) {

                    for(let x=0; x<1024; x+=tileSize) {

                        ctx.save();

                        ctx.translate(x, y);

                        // 随机细微色差模拟真实木头

                        ctx.fillStyle = `hsl(25, 30%, ${25 + Math.random()*10}%)`;

                        ctx.fillRect(2, 2, tileSize-4, tileSize-4);

                       

                        // 木纹线条

                        ctx.globalAlpha = 0.1;

                        for(let i=0; i<10; i++) {

                            ctx.beginPath();

                            ctx.moveTo(0, Math.random()*tileSize);

                            ctx.lineTo(tileSize, Math.random()*tileSize);

                            ctx.stroke();

                        }

                        ctx.restore();

                    }

                }

               

                const tex = new THREE.CanvasTexture(canvas);

                tex.wrapS = THREE.RepeatWrapping;

                tex.wrapT = THREE.RepeatWrapping;

                tex.repeat.set(8, 8);

                return tex;

            },



            // 生成经典的博物馆墙面纹理 (带噪点和纹理的石膏/织物感)

            createWall: function() {

                const canvas = document.createElement('canvas');

                canvas.width = 512; canvas.height = 512;

                const ctx = canvas.getContext('2d');

               

                // 深红/暗红色背景 (类似卢浮宫红厅)

                ctx.fillStyle = '#781f1f';

                ctx.fillRect(0,0,512,512);

               

                // 添加噪点

                for(let i=0; i<50000; i++) {

                    ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.1})`;

                    ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);

                }

               

                // 淡淡的锦缎图案

                ctx.strokeStyle = 'rgba(0,0,0,0.1)';

                ctx.lineWidth = 5;

                for(let i=0; i<10; i++) {

                    ctx.beginPath();

                    ctx.arc(Math.random()*512, Math.random()*512, 50, 0, Math.PI*2);

                    ctx.stroke();

                }



                const tex = new THREE.CanvasTexture(canvas);

                tex.wrapS = THREE.RepeatWrapping;

                tex.wrapT = THREE.RepeatWrapping;

                tex.repeat.set(4, 2);

                return tex;

            }

        };



        // ==========================================

        // 2. 核心场景设置

        // ==========================================

        let scene, camera, renderer, controls;

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        let prevTime = performance.now();

        const velocity = new THREE.Vector3();

        const direction = new THREE.Vector3();



        function init() {

            // 场景

            scene = new THREE.Scene();

            scene.background = new THREE.Color(0x111111);

            // 添加雾效增加深邃感

            scene.fog = new THREE.FogExp2(0x111111, 0.015);



            // 相机

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);

            camera.position.y = 1.7; // 人眼高度



            // 渲染器 (开启高质量阴影)

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });

            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.shadowMap.enabled = true;

            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 柔和阴影

            renderer.outputEncoding = THREE.sRGBEncoding; // 正确的颜色空间

            renderer.toneMapping = THREE.ACESFilmicToneMapping; // 电影级色调映射

            renderer.toneMappingExposure = 1.0;

            document.getElementById('container').appendChild(renderer.domElement);



            // 控制器

            controls = new THREE.PointerLockControls(camera, document.body);



            // 交互逻辑

            const startBtn = document.getElementById('start-btn');

            const uiLayer = document.getElementById('ui-layer');

           

            startBtn.addEventListener('click', () => {

                controls.lock();

            });



            controls.addEventListener('lock', () => {

                uiLayer.style.opacity = '0';

                setTimeout(() => uiLayer.style.display = 'none', 500);

            });



            controls.addEventListener('unlock', () => {

                uiLayer.style.display = 'flex';

                setTimeout(() => uiLayer.style.opacity = '1', 10);

            });



            setupInputs();

            buildGallery();

            setupLighting();

            animate();



            window.addEventListener('resize', onWindowResize);

        }



        // ==========================================

        // 3. 展厅建筑构建 (Architecture)

        // ==========================================

        function buildGallery() {

            const hallWidth = 20;

            const hallLength = 60;

            const hallHeight = 8;



            // --- 地板 (PBR 材质) ---

            const floorGeo = new THREE.PlaneGeometry(hallWidth, hallLength);

            const floorMat = new THREE.MeshStandardMaterial({

                map: TextureGen.createParquet(),

                roughness: 0.2, // 抛光木地板

                metalness: 0.0,

                color: 0xffffff

            });

            const floor = new THREE.Mesh(floorGeo, floorMat);

            floor.rotation.x = -Math.PI / 2;

            floor.receiveShadow = true;

            scene.add(floor);



            // --- 墙壁 ---

            const wallMat = new THREE.MeshStandardMaterial({

                map: TextureGen.createWall(),

                roughness: 0.9,

                color: 0xffffff

            });



            // 左墙

            const wallGeoSide = new THREE.BoxGeometry(1, hallHeight, hallLength);

            const wallLeft = new THREE.Mesh(wallGeoSide, wallMat);

            wallLeft.position.set(-hallWidth/2, hallHeight/2, 0);

            wallLeft.receiveShadow = true;

            wallLeft.castShadow = true;

            scene.add(wallLeft);



            // 右墙

            const wallRight = new THREE.Mesh(wallGeoSide, wallMat);

            wallRight.position.set(hallWidth/2, hallHeight/2, 0);

            wallRight.receiveShadow = true;

            wallRight.castShadow = true;

            scene.add(wallRight);



            // 后墙

            const wallGeoEnd = new THREE.BoxGeometry(hallWidth + 2, hallHeight, 1);

            const wallBack = new THREE.Mesh(wallGeoEnd, wallMat);

            wallBack.position.set(0, hallHeight/2, -hallLength/2);

            wallBack.receiveShadow = true;

            scene.add(wallBack);



            // 前墙 (入口)

            const wallFront = new THREE.Mesh(wallGeoEnd, wallMat);

            wallFront.position.set(0, hallHeight/2, hallLength/2);

            wallFront.receiveShadow = true;

            scene.add(wallFront);



            // --- 天花板 (拱形结构) ---

            const ceilingGeo = new THREE.CylinderGeometry(hallWidth/2, hallWidth/2, hallLength, 32, 1, true, 0, Math.PI);

            const ceilingMat = new THREE.MeshStandardMaterial({

                color: 0xe0e0e0, // 白色石膏

                roughness: 1.0,

                side: THREE.DoubleSide

            });

            const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);

            ceiling.rotation.y = -Math.PI / 2; // 对齐长廊

            ceiling.rotation.z = Math.PI / 2;  // 拱起

            ceiling.position.set(0, hallHeight, 0);

            scene.add(ceiling);



            // --- 踢脚线和装饰条 (增加细节) ---

            const skirtingGeo = new THREE.BoxGeometry(1, 0.6, hallLength);

            const skirtingMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });

           

            const skLeft = new THREE.Mesh(skirtingGeo, skirtingMat);

            skLeft.position.set(-hallWidth/2 + 0.5, 0.3, 0);

            scene.add(skLeft);

           

            const skRight = new THREE.Mesh(skirtingGeo, skirtingMat);

            skRight.position.set(hallWidth/2 - 0.5, 0.3, 0);

            scene.add(skRight);



            // --- 放置画作 (槽位) ---

            // 参数: 图片URL (或颜色), 墙壁位置('left'/'right'/'back'), 沿墙坐标, 尺寸

           

            // 左墙画作

            createPainting('https://picsum.photos/id/1015/800/1200', 'left', -15, 3, 4, "风景");

            createPainting('https://picsum.photos/id/1016/1000/800', 'left', -5, 4, 3, "峡谷");

            createPainting('https://picsum.photos/id/1003/800/800', 'left', 5, 3, 3, "鹿");

            createPainting('https://picsum.photos/id/1025/600/900', 'left', 15, 2.5, 3.5, "森林");



            // 右墙画作

            createPainting('https://picsum.photos/id/237/800/1000', 'right', -15, 3, 4, "黑犬");

            createPainting('https://picsum.photos/id/433/1000/700', 'right', -5, 4, 2.8, "肖像");

            createPainting('https://picsum.photos/id/593/800/800', 'right', 5, 3, 3, "老虎");

            createPainting('https://picsum.photos/id/659/600/900', 'right', 15, 2.5, 3.5, "雪狼");



            // 尽头主画 (如蒙娜丽莎位)

            createPainting('https://img.allhistory.com/5f0c1225a4188f0001a96678.jpg?imageView2/2/w/824/|imageMogr2/strip/interlace/1/quality/75/format/jpg', 'back', 0, 5, 7, "大师之作");



            // 长椅 (增加空间参照物)

            createBench(0, 0);

            createBench(0, -15);

            createBench(0, 15);

        }



        // ==========================================

        // 4. 画作创建系统 (真实感核心)

        // ==========================================

        function createPainting(imageUrl, wallSide, zOffset, width, height, title) {

            const group = new THREE.Group();

           

            // 1. 复杂金框 (使用多个几何体模拟雕花边框)

            const frameColor = 0xcfaa56; // 沉稳的金色

            const frameMat = new THREE.MeshStandardMaterial({

                color: frameColor,

                roughness: 0.3,

                metalness: 0.8

            });



            // 外框

            const frameThick = 0.2;

            const frameDepth = 0.3;

            const outerGeo = new THREE.BoxGeometry(width + frameThick*2, height + frameThick*2, frameDepth);

            const outerFrame = new THREE.Mesh(outerGeo, frameMat);

            outerFrame.castShadow = true;

            group.add(outerFrame);



            // 内衬 (画布背板)

            const canvasGeo = new THREE.PlaneGeometry(width, height);

           

            // 加载纹理

            const textureLoader = new THREE.TextureLoader();

            // 如果图片加载失败，使用灰色代替

            const texture = textureLoader.load(imageUrl,

                function(tex) {

                    tex.encoding = THREE.sRGBEncoding;

                },

                undefined,

                function(err) { console.error("Error loading image"); }

            );



            const canvasMat = new THREE.MeshStandardMaterial({

                map: texture,

                roughness: 0.6,

                color: 0xffffff

            });

           

            const canvasMesh = new THREE.Mesh(canvasGeo, canvasMat);

            canvasMesh.position.z = frameDepth/2 + 0.01; // 稍微突出一点

            group.add(canvasMesh);



            // 2. 专用照明 (博物馆重点照明)

            const spotLight = new THREE.SpotLight(0xfff5e6, 2.5); // 暖白光

            spotLight.angle = Math.PI / 6;

            spotLight.penumbra = 0.5; // 边缘柔和

            spotLight.decay = 2;

            spotLight.distance = 20;

            spotLight.castShadow = true;

            spotLight.shadow.mapSize.width = 512;

            spotLight.shadow.mapSize.height = 512;



            // 定位画框和灯光

            const hallWidth = 20;

            const yPos = height/2 + 2; // 挂画高度



            if (wallSide === 'left') {

                group.position.set(-hallWidth/2 + 0.7, yPos, zOffset);

                group.rotation.y = Math.PI / 2;

               

                // 灯光位置：天花板偏向画作一侧

                spotLight.position.set(-hallWidth/2 + 5, 7, zOffset);

                spotLight.target = canvasMesh;

            } else if (wallSide === 'right') {

                group.position.set(hallWidth/2 - 0.7, yPos, zOffset);

                group.rotation.y = -Math.PI / 2;



                spotLight.position.set(hallWidth/2 - 5, 7, zOffset);

                spotLight.target = canvasMesh;

            } else if (wallSide === 'back') {

                group.position.set(0, yPos, -30 + 0.6); // -hallLength/2

               

                spotLight.position.set(0, 7, -20);

                spotLight.target = canvasMesh;

            }



            scene.add(group);

            scene.add(spotLight);

            // SpotLight target 必须也在场景中

            // 由于 target 是 canvasMesh，它是 group 的子元素，已经被添加到场景间接中

            // 但 Threejs 有时需要手动更新

        }



        function createBench(x, z) {

            const benchGroup = new THREE.Group();

           

            // 座垫 (红色天鹅绒)

            const seatGeo = new THREE.BoxGeometry(2, 0.5, 4);

            const seatMat = new THREE.MeshStandardMaterial({ color: 0x800000, roughness: 1.0 });

            const seat = new THREE.Mesh(seatGeo, seatMat);

            seat.position.y = 0.5;

            seat.castShadow = true;

            benchGroup.add(seat);



            // 腿 (金色)

            const legGeo = new THREE.BoxGeometry(1.8, 0.5, 3.8);

            const legMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });

            const leg = new THREE.Mesh(legGeo, legMat);

            leg.position.y = 0.25;

            benchGroup.add(leg);



            benchGroup.position.set(x, 0, z);

            scene.add(benchGroup);

        }



        // ==========================================

        // 5. 灯光系统

        // ==========================================

        function setupLighting() {

            // 环境光 (基础亮度，偏冷色)

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);

            scene.add(ambientLight);



            // 半球光 (模拟天光和地面的反光)

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);

            scene.add(hemiLight);

        }



        // ==========================================

        // 6. 输入与物理控制

        // ==========================================

        function setupInputs() {

            document.addEventListener('keydown', (event) => {

                switch (event.code) {

                    case 'ArrowUp': case 'KeyW': moveForward = true; break;

                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;

                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;

                    case 'ArrowRight': case 'KeyD': moveRight = true; break;

                }

            });



            document.addEventListener('keyup', (event) => {

                switch (event.code) {

                    case 'ArrowUp': case 'KeyW': moveForward = false; break;

                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;

                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;

                    case 'ArrowRight': case 'KeyD': moveRight = false; break;

                }

            });

        }



        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }



        // ==========================================

        // 7. 动画循环

        // ==========================================

        function animate() {

            requestAnimationFrame(animate);



            if (controls.isLocked === true) {

                const time = performance.now();

                const delta = (time - prevTime) / 1000;



                // 阻尼效果 (停下来时有平滑减速)

                velocity.x -= velocity.x * 10.0 * delta;

                velocity.z -= velocity.z * 10.0 * delta;



                direction.z = Number(moveForward) - Number(moveBackward);

                direction.x = Number(moveRight) - Number(moveLeft);

                direction.normalize();



                // 移动速度 (博物馆步行速度，不要太快)

                const speed = 40.0;

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;

                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;



                controls.moveRight(-velocity.x * delta);

                controls.moveForward(-velocity.z * delta);



                // 简单的边界限制 (防止走出房间)

                const pos = controls.getObject().position;

                if (pos.x < -9) pos.x = -9;

                if (pos.x > 9) pos.x = 9;

                if (pos.z < -29) pos.z = -29;

                if (pos.z > 29) pos.z = 29;

            }



            prevTime = performance.now();

            renderer.render(scene, camera);

        }



        // 启动

        init();



    </script>

</body>

</html>