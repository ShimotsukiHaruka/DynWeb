<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>真实风展览馆（可走动）</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <style>
        *{box-sizing:border-box;margin:0;padding:0}
        html,body{width:100%;height:100%}
        body{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background:#0b0f12;color:#fff;overflow:hidden
        }
        #container{position:absolute;inset:0}
        #ui{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:200;pointer-events:auto}
        .menu{background:rgba(255,255,255,0.95);color:#222;padding:20px;border-radius:12px;min-width:320px;box-shadow:0 10px 30px rgba(0,0,0,0.4)}
        h1{font-size:1.5rem;margin-bottom:6px}
        p.sub{color:#555;margin-bottom:12px}
        .hall-buttons{display:flex;flex-wrap:wrap;gap:10px}
        .btn{flex:1;padding:10px 12px;border-radius:8px;border:none;background:#2b6be6;color:#fff;font-weight:600;cursor:pointer}
        .btn.secondary{background:#4a4a4a}
        #help{position:absolute;left:16px;bottom:16px;background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;pointer-events:none}
        .cross{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:24px;height:24px;pointer-events:none;z-index:150}
        .cross:before,.cross:after{content:'';position:absolute;background:rgba(255,255,255,0.9)}
        .cross:before{height:2px;width:24px;left:0;top:11px}
        .cross:after{width:2px;height:24px;left:11px;top:0}
        #logo{position:absolute;right:20px;top:20px;background:rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px}
        @media (max-width:768px){.menu{min-width:260px}}
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="ui">
        <div class="menu" id="menu">
            <h1>博物馆入口</h1>
            <p class="sub">WASD 移动 · 鼠标转头 · 空格跳跃 · Esc 返回菜单</p>
            <div style="margin-bottom:10px">选择要直接前往的展厅（或在大厅自然行走）：</div>
            <div class="hall-buttons">
                <button class="btn" data-target="modern">现代艺术馆</button>
                <button class="btn" data-target="classical">古典艺术馆</button>
                <button class="btn" data-target="abstract">抽象艺术馆</button>
                <button class="btn" data-target="digital">数字艺术馆</button>
            </div>
            <div style="margin-top:12px;display:flex;gap:8px">
                <button id="enterBtn" class="btn">进入大厅（漫步体验）</button>
                <button id="closeBtn" class="btn secondary">关闭菜单</button>
            </div>
        </div>
    </div>

    <div id="help">WASD · 鼠标 · 空格 · E（互动）</div>
    <div class="cross"></div>
    <div id="logo">真实风展览馆样例</div>

    <script>
    // ---------- 基本变量 ----------
    let camera, scene, renderer, controls;
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
    let canJump=false, velocity=new THREE.Vector3(), direction=new THREE.Vector3();
    let prevTime=performance.now();
    const playerRadius=0.6, playerHeight=1.8;

    const container=document.getElementById('container');

    // 碰撞对象（盒子/圆柱）
    const collisionObjects=[];

    // 初始化
    init();
    animate();

    function init(){
        scene=new THREE.Scene();
        scene.background=new THREE.Color(0x0b0f12);

        camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
        camera.position.set(0,1.8,8);

        // renderer
        renderer=new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth,window.innerHeight);
        renderer.shadowMap.enabled=true;
        container.appendChild(renderer.domElement);

        // lights - 多光源营造不同空间质感
        const amb=new THREE.HemisphereLight(0xffffff,0x444444,0.5); scene.add(amb);
        const dir=new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(5,20,10); dir.castShadow=true; scene.add(dir);

        // 地面 - 大厅大理石
        const hallFloor=new THREE.Mesh(
            new THREE.PlaneGeometry(120,120),
            new THREE.MeshStandardMaterial({color:0xf4f4f6,roughness:0.4,metalness:0.02})
        );
        hallFloor.rotation.x=-Math.PI/2; hallFloor.receiveShadow=true; scene.add(hallFloor);

        // 中央大厅装饰
        createCentralHall();

        // 4 个展厅（实体入口）
        createGalleryWithEntrance('modern', 0, 0, -32, {title:'现代艺术馆', color:0x2d6cdf, ambient:0x9fc3ff});
        createGalleryWithEntrance('abstract', -32, 0, 0, {title:'抽象艺术馆', color:0xe85a5a, ambient:0xffb6b6});
        createGalleryWithEntrance('digital', 32, 0, 0, {title:'数字艺术馆', color:0x2ecc71, ambient:0x9df0b0});
        createGalleryWithEntrance('classical', 0, 0, 32, {title:'古典艺术馆', color:0xd4af37, ambient:0xfff0c2});

        // pointer lock controls
        controls=new THREE.PointerLockControls(camera, document.body);

        // 事件绑定 - 菜单按钮
        document.querySelectorAll('.btn[data-target]').forEach(b=>{
            b.addEventListener('click',()=>{
                const t=b.getAttribute('data-target');
                // 快速传送到展厅入口前，保留漫步体验
                const ent=scene.getObjectByName('entrance_'+t);
                if(ent){
                    controls.getObject().position.set(ent.position.x,1.8,ent.position.z+4);
                    controls.getObject().lookAt(ent.position.x,1.8,ent.position.z);
                }
                lockAndHideMenu();
            });
        });

        document.getElementById('enterBtn').addEventListener('click', ()=>{ lockAndHideMenu(); });
        document.getElementById('closeBtn').addEventListener('click', ()=>{ document.getElementById('ui').style.display='none'; controls.lock(); });

        controls.addEventListener('lock', ()=>{ document.getElementById('ui').style.display='none'; });
        controls.addEventListener('unlock', ()=>{ document.getElementById('ui').style.display='block'; });

        // 键盘事件
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        window.addEventListener('resize', onWindowResize);

        // 鼠标Esc返回菜单：当解除锁定，菜单显示（PointerLockControls 默认 Esc 解锁）
    }

    function lockAndHideMenu(){ controls.lock(); document.getElementById('ui').style.display='none'; }

    function createCentralHall(){
        // 大厅：抬高地面内嵌圆形纹理（用材质变化表现）
        const ring=new THREE.Mesh(new THREE.RingGeometry(6,10,64), new THREE.MeshStandardMaterial({color:0x222a33,side:THREE.DoubleSide,roughness:0.5}));
        ring.rotation.x=-Math.PI/2; ring.position.y=0.01; scene.add(ring);

        // 中央雕塑（抽象）
        const geom=new THREE.TorusKnotGeometry(2,0.4,128,12); const mat=new THREE.MeshStandardMaterial({color:0x9aa6ad,metalness:0.6,roughness:0.3});
        const sculpture=new THREE.Mesh(geom,mat); sculpture.position.set(0,2.3,0); sculpture.castShadow=true; scene.add(sculpture);
        collisionObjects.push({type:'cylinder',position:new THREE.Vector3(0,1.6,0),radius:2.5,height:3});

        // 四个方向的浮动牌（3D板子）
        createSign(0,2.4,-14,'现代艺术');
        createSign(-14,2.4,0,'抽象艺术');
        createSign(14,2.4,0,'数字艺术');
        createSign(0,2.4,14,'古典艺术');
    }

    function createSign(x,y,z,text){
        const plate=new THREE.Mesh(new THREE.BoxGeometry(6,1.2,0.4), new THREE.MeshStandardMaterial({color:0x111827,roughness:0.6}));
        plate.position.set(x,y,z); plate.castShadow=false; scene.add(plate);
        // 简单文字效果：用白色平面代表（浏览器内制作Text需要字体资源，简化为平面与小立方作为装饰）
        const label=new THREE.Mesh(new THREE.BoxGeometry(5.5,0.6,0.01), new THREE.MeshBasicMaterial({color:0xffffff}));
        label.position.set(x,y+0.01,z+0.21); scene.add(label);
    }

    // 创建展厅及带开口的墙入口
    function createGalleryWithEntrance(id, px, py, pz, opts){
        const roomGroup=new THREE.Group(); roomGroup.name='gallery_'+id; roomGroup.position.set(px,0,pz);

        // 房间地面
        const floor=new THREE.Mesh(new THREE.PlaneGeometry(24,24), new THREE.MeshStandardMaterial({color:opts.color,roughness:0.6,metalness:0.02}));
        floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; floor.position.y=0.01; roomGroup.add(floor);

        // 四周墙体（有入口缺口）
        const wallMat=new THREE.MeshStandardMaterial({color:0xf8f8f8});
        const wallThickness=0.8, wallHeight=6;
        // 后墙
        const backWall=new THREE.Mesh(new THREE.BoxGeometry(24,wallHeight,wallThickness), wallMat);
        backWall.position.set(0,wallHeight/2,-12+wallThickness/2); roomGroup.add(backWall); collisionObjects.push({type:'box',position:new THREE.Vector3(px+0,wallHeight/2,pz-12+wallThickness/2),width:24,height:wallHeight,depth:wallThickness});

        // 左墙 - 留出中间门洞
        const leftWallLeft=new THREE.Mesh(new THREE.BoxGeometry(6,wallHeight,wallThickness), wallMat); leftWallLeft.position.set(-9,wallHeight/2,0); roomGroup.add(leftWallLeft); collisionObjects.push({type:'box',position:new THREE.Vector3(px-9,wallHeight/2,pz+0),width:6,height:wallHeight,depth:wallThickness});
        const leftWallRight=new THREE.Mesh(new THREE.BoxGeometry(6,wallHeight,wallThickness), wallMat); leftWallRight.position.set(-1,wallHeight/2,0); roomGroup.add(leftWallRight); collisionObjects.push({type:'box',position:new THREE.Vector3(px-1,wallHeight/2,pz+0),width:6,height:wallHeight,depth:wallThickness});
        // 门洞在 x=-4 处留空，玩家可以通过

        // 右墙
        const rightWallLeft=new THREE.Mesh(new THREE.BoxGeometry(6,wallHeight,wallThickness), wallMat); rightWallLeft.position.set(1,wallHeight/2,0); roomGroup.add(rightWallLeft); collisionObjects.push({type:'box',position:new THREE.Vector3(px+1,wallHeight/2,pz+0),width:6,height:wallHeight,depth:wallThickness});
        const rightWallRight=new THREE.Mesh(new THREE.BoxGeometry(6,wallHeight,wallThickness), wallMat); rightWallRight.position.set(9,wallHeight/2,0); roomGroup.add(rightWallRight); collisionObjects.push({type:'box',position:new THREE.Vector3(px+9,wallHeight/2,pz+0),width:6,height:wallHeight,depth:wallThickness});

        // 前墙（有门洞对着大厅） - 我们在靠近大厅的一侧留一个大门
        const frontLeft=new THREE.Mesh(new THREE.BoxGeometry(8,wallHeight,wallThickness), wallMat); frontLeft.position.set(-8,wallHeight/2,12-wallThickness/2); roomGroup.add(frontLeft); collisionObjects.push({type:'box',position:new THREE.Vector3(px-8,wallHeight/2,pz+12-wallThickness/2),width:8,height:wallHeight,depth:wallThickness});
        const frontRight=new THREE.Mesh(new THREE.BoxGeometry(8,wallHeight,wallThickness), wallMat); frontRight.position.set(8,wallHeight/2,12-wallThickness/2); roomGroup.add(frontRight); collisionObjects.push({type:'box',position:new THREE.Vector3(px+8,wallHeight/2,pz+12-wallThickness/2),width:8,height:wallHeight,depth:wallThickness});
        // 中间 8 单位作为门洞，允许玩家通过

        // 门楣装饰
        const arch=new THREE.Mesh(new THREE.BoxGeometry(8,1.2,0.6), new THREE.MeshStandardMaterial({color:0x222222}));
        arch.position.set(0,4.2,12-0.3); roomGroup.add(arch);

        // 展厅内装饰：几个画框或雕塑，根据风格调整
        for(let i=0;i<4;i++){
            const p=new THREE.Mesh(new THREE.BoxGeometry(3,2.2,0.2), new THREE.MeshStandardMaterial({color:0xffffff}));
            p.position.set(-6 + i*4,1.2,-8);
            roomGroup.add(p);
            collisionObjects.push({type:'box',position:new THREE.Vector3(px + (-6 + i*4),1.2,pz-8),width:3,height:2.2,depth:0.2});
        }

        // 名称牌（在门口上方）
        const namePlate=new THREE.Mesh(new THREE.BoxGeometry(6,0.8,0.2), new THREE.MeshStandardMaterial({color:0x111111}));
        namePlate.position.set(0,5.2,12-0.25); roomGroup.add(namePlate);

        // 入口标识，便于菜单快速传送
        const entrance=new THREE.Object3D(); entrance.name='entrance_'+id; entrance.position.set(px,0,pz+12);
        scene.add(entrance);

        // 根据风格调整内部光照
        const localLight=new THREE.PointLight(opts.ambient,1.2,40); localLight.position.set(0,5,0); roomGroup.add(localLight);

        scene.add(roomGroup);
    }

    // 简化碰撞检测（盒/圆柱）
    function checkCollision(pos){
        for(let obj of collisionObjects){
            if(obj.type==='box'){
                const halfW=obj.width/2, halfH=obj.height/2, halfD=obj.depth/2;
                const minX=obj.position.x-halfW, maxX=obj.position.x+halfW;
                const minY=obj.position.y-halfH, maxY=obj.position.y+halfH;
                const minZ=obj.position.z-halfD, maxZ=obj.position.z+halfD;
                if(pos.x+playerRadius>minX && pos.x-playerRadius<maxX && pos.y<maxY && pos.y+playerHeight>minY && pos.z+playerRadius>minZ && pos.z-playerRadius<maxZ) return true;
            } else if(obj.type==='cylinder' || obj.type==='sculpture'){
                const dx=pos.x-obj.position.x, dz=pos.z-obj.position.z; const dist=Math.sqrt(dx*dx+dz*dz);
                if(dist < (obj.radius + playerRadius) && pos.y < obj.position.y + (obj.height||3) && pos.y + playerHeight > obj.position.y - (obj.height||0)) return true;
            }
        }
        return false;
    }

    function onWindowResize(){ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }

    function onKeyDown(e){
        switch(e.code){
            case 'ArrowUp': case 'KeyW': moveForward=true; break;
            case 'ArrowLeft': case 'KeyA': moveLeft=true; break;
            case 'ArrowDown': case 'KeyS': moveBackward=true; break;
            case 'ArrowRight': case 'KeyD': moveRight=true; break;
            case 'Space': if(canJump){ velocity.y += 6; canJump=false;} break;
            case 'Escape': controls.unlock(); document.getElementById('ui').style.display='block'; break;
        }
    }
    function onKeyUp(e){
        switch(e.code){
            case 'ArrowUp': case 'KeyW': moveForward=false; break;
            case 'ArrowLeft': case 'KeyA': moveLeft=false; break;
            case 'ArrowDown': case 'KeyS': moveBackward=false; break;
            case 'ArrowRight': case 'KeyD': moveRight=false; break;
        }
    }

    function animate(){
        requestAnimationFrame(animate);
        const time=performance.now();
        const delta=(time-prevTime)/1000;
        if(controls.isLocked===true){
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 2.0 * delta; // 简化重力

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if(moveForward || moveBackward) velocity.z -= direction.z * 6.0 * delta * 60;
            if(moveLeft || moveRight) velocity.x -= direction.x * 6.0 * delta * 60;

            // 保存位置
            const oldPos = controls.getObject().position.clone();

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            controls.getObject().position.y += velocity.y * delta;

            // 地面高度（固定为 1.8）
            if(controls.getObject().position.y < 1.8){ velocity.y = 0; controls.getObject().position.y = 1.8; canJump=true; }

            // 碰撞
            if(checkCollision(controls.getObject().position)){
                controls.getObject().position.copy(oldPos);
                velocity.x = 0; velocity.z = 0;
            }
        }
        renderer.render(scene,camera);
        prevTime=time;
    }

    </script>
</body>
</html>
